package com.briefjoe.mod.init.entity;

import com.briefjoe.mod.init.entity.golem.EntityCustomGolem;

import net.minecraft.block.Block;
import net.minecraft.world.World;

public class GolemRegistration {
	BlockWithMeta upperBody, lowerBody, shoulders, arms, legs;
	protected Class<? extends EntityCustomGolem> golemClass;
	public final boolean smart, villageSpawnable;
	private String golemName;

	/**
	 * Full constructor: all other constructors delegate to this one. Also
	 * precomputes smartness assertion via reflection.
	 * 
	 * @param golemClass
	 *            The class of the golem this registration is for
	 * @param upperBody
	 *            The block used as the golem's uppper body
	 * @param lowerBody
	 *            The block used as the golem's lower body
	 * @param shoulders
	 *            The block used as the golem's shoulders
	 * @param arms
	 *            The block used as the golem's arms
	 * @param legs
	 *            The block used as the golem's legs
	 */
	public GolemRegistration(Class<? extends EntityCustomGolem> golemClass, BlockWithMeta upperBody,
			BlockWithMeta lowerBody, BlockWithMeta shoulders, BlockWithMeta arms, BlockWithMeta legs) {
		this.golemClass = golemClass;
		this.upperBody = upperBody != null ? upperBody : new BlockWithMeta(null);
		this.lowerBody = lowerBody != null ? lowerBody : new BlockWithMeta(null);
		;
		this.shoulders = shoulders != null ? shoulders : new BlockWithMeta(null);
		;
		this.arms = arms != null ? arms : new BlockWithMeta(null);
		;
		this.legs = legs != null ? legs : new BlockWithMeta(null);
		;
		boolean tsmart = false, tvillage = true;
		try {
			GolemStats stats = (GolemStats) golemClass.getDeclaredField("stats").get(null);
			tsmart = stats.smart;
			tvillage = stats.villageSpawnable;
		} catch (Exception ex) {
			ex.printStackTrace();
		} finally {
			this.smart = tsmart;
			this.villageSpawnable = tvillage;
		}
	}

	/**
	 * Checks if a a valid multiblock for this golem is constructed with its
	 * head at coords (x,y,z).
	 * 
	 * @param world
	 *            The {@link World} to check in
	 * @param x
	 *            The x coord to check at
	 * @param y
	 *            The y coord to check at
	 * @param z
	 *            The z coord to check at
	 * @param clearShape
	 *            Whether or not to remove the affected blocks on successful
	 *            match
	 * @return Whether or not a golem is correctly built at the specified
	 *         location
	 */
	public boolean checkAt(World world, int x, int y, int z, boolean clearShape) {
		int headID = world.getBlockId(x, y, z);
		TransactionDeleteBlocks remove = clearShape ? new TransactionDeleteBlocks() : null;
		if (headID == Block.pumpkinLantern.blockID || !smart && headID == Block.pumpkin.blockID) {
			if (upperBody.isAt(world, x, y - 1, z, remove) && lowerBody.isAt(world, x, y - 2, z, remove)) {
				// Check +-x first
				if (shoulders.isAt(world, x - 1, y, z, remove) && shoulders.isAt(world, x + 1, y, z, remove)
						&& arms.isAt(world, x - 1, y - 1, z, remove) && arms.isAt(world, x + 1, y - 1, z, remove)
						&& legs.isAt(world, x - 1, y - 1, z, remove) && legs.isAt(world, x + 1, y - 1, z, remove)) {
					if (clearShape) {
						world.setBlockToAir(x, y, z);
						remove.commit();
					}
					return true;
				} else if (clearShape) {
					remove.abort();
				}
				remove.addAction(world, x, y - 1, z);
				remove.addAction(world, x, y - 2, z);
				// Check +-z now
				if (shoulders.isAt(world, x, y, z - 1, remove) && shoulders.isAt(world, x, y, z + 1, remove)
						&& arms.isAt(world, x, y - 1, z - 1, remove) && arms.isAt(world, x, y - 1, z + 1, remove)
						&& legs.isAt(world, x, y - 1, z - 1, remove) && legs.isAt(world, x, y - 1, z + 1, remove)) {
					if (clearShape) {
						world.setBlockToAir(x, y, z);
						remove.commit();
					}
					return true;
				} else if (clearShape) {
					remove.abort();
				}
			}
		}
		return false;
	}

	/**
	 * Spawns a golem if this registration's type at the specified location via
	 * reflection.
	 * 
	 * @param world
	 *            The world to spawn the golem in
	 * @param x
	 *            The x coord to spawn at
	 * @param y
	 *            The y coord to spawn at
	 * @param z
	 *            The z coord to spawn at
	 * @return
	 */
	public EntityCustomGolem spawn(World world, double x, double y, double z) {
		EntityCustomGolem theGolem = null;
		try {
			theGolem = golemClass.getConstructor(World.class).newInstance(world);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		if (theGolem != null) {
			theGolem.setLocationAndAngles(x, y, z, 0, 0);
			world.spawnEntityInWorld(theGolem);
		}
		return theGolem;
	}

	public String getGolemName() {
		if (this.golemName == null) {
			try {
				this.golemName = ((GolemStats) this.golemClass.getDeclaredField("stats").get(null)).name;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return this.golemName;
	}
}
